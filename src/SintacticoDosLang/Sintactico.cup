package SintacticoDosLang;
import java.util.ArrayList;
import java_cup.runtime.*;
import doslang.DosLang;
import Excepciones.Excepcion;
import Excepciones.Excepcion.TIPOERROR;
import Expresiones.Identificador;
import Expresiones.Nil;
import Expresiones.Operacion;
import Expresiones.Operacion.Operador;
import Expresiones.Primitivo;
import Instrucciones.DeclaracionType;
import Instrucciones.DeclaracionVar;
import Instrucciones.DeclaracionConstante;
import Instrucciones.Program;
import Interfaces.AST;
import TablaSimbolos.Tipo;
import TablaSimbolos.Tree;
import Interfaces.Expresion;
import Instrucciones.Asignacion;
import Instrucciones.Variable;
parser code 
{:
    Tree tree;
    public Tree getArbol() {
            return tree;
    }
    public void syntax_error(Symbol s){ 
            System.err.println("Error Sintáctico en la Línea " + s.left +" Columna "+s.right+ ". No se esperaba este componente: " +s.value); 
            DosLang.errores.add(new Excepcion(TIPOERROR.SINTACTICO, "No se esperaba el token: "+s.value, s.left, s.right));
    } 

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
            System.err.println("Error síntactico en la Línea " + s.left+ "__Columna "+s.right+ ". No se esperaba este componente: " +s.value); 
            DosLang.errores.add(new Excepcion(TIPOERROR.SINTACTICO, "No se esperaba el token: "+s.value, s.left, s.right));
    }  
:}

/* Terminals (tokens returned by the scanner). */
terminal String numero, decimal, igual, pComa, cadena, identificador;
terminal String integer, real, character, bool, word, string, record, nil;
terminal String type, coma, parenI, parenD, tresP, array, corI, corD, dosP;
terminal String of, sizeof, malloc, free, and, begin, caso, constante, hacer;
terminal String downto, sino, end, para, function, si;
terminal String not, or, procedure, program, repeat, then;
terminal String to, until, var, punto, mientras, con, uses, dosPuntos;
terminal String potencia, modulo, menorque, menorigual, mayorque, mayorigual;
terminal String igualacion, diferente, nand, nor, falso, verdadero;
terminal String mas, menos, por, division, UMENOS, leer;
terminal String detener, continuar, salir, escribir, escribirln;
terminal char caracter;
/* Non terminals */
non terminal INICIO;
non terminal ENUM_TYPE, ARRAY_TYPE;
non terminal RANGO_ARRAY, ARRAY_DECLARATION, MEMORIA_VIRTUAL;
non terminal PARAMETROS;
non terminal LISTA_PARAMETROS, CUERPO_FUNCION, BLOQUE_INSTRUCCIONES;
non terminal FUNCION, WITH, PROCEDURE, ARRAY_MULTI;
non terminal METHOD_LIST, SI, LISTAIF, INSTRUCCIONESIF;
non terminal TRANSFERENCIA, LISTAIFFINAL, WHILE, REPEAT, FOR, WRITE, READ;
non terminal REGISTRO, LISTA_RECORDS, RECORDS;
non terminal CASE, CASELIST, DEFECTO, SWITCH, ARRAY_DECLARATION_MULTI, LISTA_RANGO_ARRAY;
non terminal INSIF;


non terminal ArrayList<AST> PROGRAM, USES, MAIN, SECCION_TIPO, LISTA_DECLARACION_TIPOS, LISTA_INSTRUCCIONES;
non terminal ArrayList<AST> SECCION_FUNCION, VARINIT, DECLARACION_VAR, SECCION_VAR, SECCION_CONST, DECLARACION_CONST;
non terminal ArrayList<String> LISTA_IDENTIFICADORES;
non terminal ArrayList<Expresion> VARIABLE, LISTA_EXPRESION;
non terminal AST DECLARACION_TIPOS, VAR, TIPO_DECLARACION, CONST, INSTRUCCION, ASIGNACION;
non terminal AST SUBRANGE_TYPE;
non terminal Expresion PRIMITIVO, ARITMETICA, RELACIONAL, LOGICA,EXPRESION, ACCESO, LLAMADA;
non terminal Expresion LOWER_LIMIT, UPPER_LIMIT;
non terminal Tipo TIPO, TIPO_PRIMITIVO;

precedence left then;
//precedence left sino;
precedence left or;
precedence left nand, nor;
precedence left and;
precedence left igualacion, diferente;
precedence left mayorigual, menorigual, menorque, mayorque;
precedence left mas, menos;
precedence left por, division, potencia, modulo;
precedence left potencia;
precedence left not;
precedence left UMENOS;
precedence left parenI, parenD;

start with INICIO;

INICIO ::= PROGRAM:e {: System.out.println("Termino Correctamente"); parser.tree = new Tree(e);:}
         ;

PROGRAM ::= program identificador:e pComa USES:e1 {: RESULT = new ArrayList<AST>(); RESULT.add(new Program(e)); RESULT.addAll(e1);:}
          ;

USES ::= uses LISTA_IDENTIFICADORES:e pComa SECCION_TIPO:e1 {:RESULT = e1;:}
       | SECCION_TIPO:e {:RESULT = e;:}
       ;

SECCION_TIPO ::= type LISTA_DECLARACION_TIPOS:e SECCION_CONST:e1 {:RESULT = e; RESULT.addAll(e1);:}
               | SECCION_CONST:e {:RESULT = e;:}
               ;

LISTA_DECLARACION_TIPOS ::= LISTA_DECLARACION_TIPOS:e DECLARACION_TIPOS:e1 {:RESULT = e; RESULT.add(e1);:}
                          | DECLARACION_TIPOS:e {:RESULT = new ArrayList<>(); RESULT.add(e);:}
                          ;

DECLARACION_TIPOS ::= TIPO_DECLARACION:e pComa {:RESULT = e;:}
                    //| ENUM_TYPE pComa
                    //| SUBRANGE_TYPE:e pComa {:RESULT = e;:}
                    | ARRAY_TYPE pComa
                    ;

TIPO_DECLARACION ::= LISTA_IDENTIFICADORES:e igual TIPO:e1 {:RESULT = new DeclaracionType(e1, e, eleft, eright);:}
                   | LISTA_IDENTIFICADORES igual REGISTRO
                   ;

//ENUM_TYPE ::= LISTA_IDENTIFICADORES igual parenI LISTA_EXPRESION parenD {: RESULT = new; :}
//            ;

//SUBRANGE_TYPE ::= LISTA_IDENTIFICADORES:e igual LOWER_LIMIT:e1 tresP UPPER_LIMIT:e2 {: RESULT = new DeclaracionType(new Tipo(Tipo.tipo.RANGE, null, e1, e2), e, eleft, eright); :}
//                ;

LOWER_LIMIT ::= EXPRESION:e {:RESULT = e;:}
            ; 

UPPER_LIMIT ::= EXPRESION:e {:RESULT = e;:} 
            ; 

ARRAY_TYPE ::= LISTA_IDENTIFICADORES igual ARRAY_DECLARATION
             | LISTA_IDENTIFICADORES igual ARRAY_DECLARATION_MULTI
             ;

ARRAY_DECLARATION ::= array corI RANGO_ARRAY corD of ARRAY_DECLARATION
                    | array corI RANGO_ARRAY corD of TIPO_PRIMITIVO
                    ;

RANGO_ARRAY ::= EXPRESION dosP EXPRESION
              ;

ARRAY_DECLARATION_MULTI ::= array corI ARRAY_MULTI corD of TIPO_PRIMITIVO
                          ;

ARRAY_MULTI ::= RANGO_ARRAY coma LISTA_RANGO_ARRAY
              ;

LISTA_RANGO_ARRAY ::= LISTA_RANGO_ARRAY coma RANGO_ARRAY
                    | RANGO_ARRAY
                    ;

LISTA_IDENTIFICADORES ::= LISTA_IDENTIFICADORES:e coma identificador:e1 {:RESULT = e; RESULT.add(e1);:}
                        | identificador:e {:RESULT = new ArrayList<String>(); RESULT.add(e);:}
                        ;

VARIABLE ::= identificador:e {: RESULT = new ArrayList<Expresion>(); RESULT.add(new Identificador(e, eleft, eright)); :}
           | VARIABLE corI LISTA_EXPRESION corD
           | VARIABLE parenI LISTA_EXPRESION parenD
           | VARIABLE:e punto identificador:e1 {: RESULT = e; RESULT.add(new Identificador(e1, eleft, eright)); :}
           ;

LISTA_EXPRESION ::= LISTA_EXPRESION:e coma EXPRESION:e1 {:RESULT = e; RESULT.add(e1);:}
                  | EXPRESION:e {: RESULT = new ArrayList<Expresion>(); RESULT.add(e); :}
                  ;

MEMORIA_VIRTUAL ::= sizeof parenI EXPRESION parenD
                  | malloc parenI EXPRESION parenD
                  //| free parenI EXPRESION parenD
                  ;

TIPO_PRIMITIVO ::= integer   {:RESULT = new Tipo(Tipo.tipo.INTEGER);:} 
                 | real      {:RESULT = new Tipo(Tipo.tipo.REAL);:}
                 | character {:RESULT = new Tipo(Tipo.tipo.CHAR);:}
                 | bool      {:RESULT = new Tipo(Tipo.tipo.BOOLEAN);:}
                 | word      {:RESULT = new Tipo(Tipo.tipo.WORD);:}
                 | string    {:RESULT = new Tipo(Tipo.tipo.STRING);:}
                 | record    {:RESULT = new Tipo(Tipo.tipo.RECORD);:}
                 ;

TIPO ::= identificador:e {:RESULT = new Tipo(Tipo.tipo.OBJETO, e);:}
       | LOWER_LIMIT:e1 tresP UPPER_LIMIT:e2 {:RESULT = new Tipo(Tipo.tipo.RANGE, null, e1, e2);:}
       | parenI LISTA_EXPRESION:e parenD {:RESULT = new Tipo(Tipo.tipo.ENUMERADO, null, e);:}
       | TIPO_PRIMITIVO:e {:RESULT = e;:}
       ;

SECCION_CONST ::= constante DECLARACION_CONST:e SECCION_VAR:e1 {:RESULT = e; RESULT.addAll(e1);:}
                | SECCION_VAR:e {:RESULT = e;:}
                ;

DECLARACION_CONST ::= DECLARACION_CONST:e CONST:e1 {:RESULT = e; RESULT.add(e1);:}
                   | CONST:e {:RESULT = new ArrayList<AST>(); RESULT.add(e);:}
                   ;

CONST ::= LISTA_IDENTIFICADORES:e dosPuntos TIPO:e1 igual EXPRESION:e2 pComa {: RESULT = new DeclaracionConstante(e1, e, e2, eleft, eright); :}
        ;

SECCION_VAR ::= VARINIT:e SECCION_FUNCION:e1 {:RESULT = e; RESULT.addAll(e1);:}
              | SECCION_FUNCION:e {:RESULT = e;:}
              ;

VARINIT ::= var DECLARACION_VAR:e {:RESULT = e;:}
          ;

DECLARACION_VAR ::= DECLARACION_VAR:e VAR:e1 {:RESULT = e; RESULT.add(e1);:}
                  | VAR:e {:RESULT = new ArrayList<AST>(); RESULT.add(e);:}
                  ;

VAR ::= LISTA_IDENTIFICADORES:e dosPuntos TIPO:e1 igual EXPRESION:e2 pComa {: RESULT = new DeclaracionVar(e1, e, e2, eleft, eright);:}
      | LISTA_IDENTIFICADORES:e dosPuntos TIPO:e1 pComa {: RESULT = new DeclaracionVar(e1, e, eleft, eright); :}
      | LISTA_IDENTIFICADORES dosPuntos REGISTRO pComa
      ;

SECCION_FUNCION ::= METHOD_LIST MAIN
                  | MAIN:e {:RESULT = e;:}
                  ;

METHOD_LIST ::= METHOD_LIST FUNCION
              | METHOD_LIST PROCEDURE
              | FUNCION
              | PROCEDURE
              ;

FUNCION ::= function identificador PARAMETROS dosPuntos TIPO pComa CUERPO_FUNCION
          ;

PROCEDURE ::= procedure identificador PARAMETROS pComa CUERPO_FUNCION
            ;

PARAMETROS ::= parenI LISTA_PARAMETROS parenD
             | parenI parenD
             ;

LISTA_PARAMETROS ::= LISTA_PARAMETROS pComa LISTA_IDENTIFICADORES dosPuntos TIPO
                   | LISTA_PARAMETROS pComa var LISTA_IDENTIFICADORES dosPuntos TIPO
                   | LISTA_IDENTIFICADORES dosPuntos TIPO
                   | var LISTA_IDENTIFICADORES dosPuntos TIPO
                   ;

CUERPO_FUNCION ::= VARINIT BLOQUE_INSTRUCCIONES
                 | BLOQUE_INSTRUCCIONES
                 ;

REGISTRO ::= record LISTA_RECORDS end 
           ;

LISTA_RECORDS ::= LISTA_RECORDS RECORDS
                | RECORDS
                ;

RECORDS ::= LISTA_IDENTIFICADORES dosPuntos TIPO pComa 
          | LISTA_IDENTIFICADORES dosPuntos ARRAY_DECLARATION pComa
          | LISTA_IDENTIFICADORES dosPuntos ARRAY_DECLARATION_MULTI pComa
          ;

MAIN ::= begin LISTA_INSTRUCCIONES:e end punto {:RESULT = e;:}
       | begin end punto {:RESULT = new ArrayList<AST>();:}
       ;

BLOQUE_INSTRUCCIONES ::= begin LISTA_INSTRUCCIONES:e end pComa {:RESULT = e;:}
                       | begin end pComa {:RESULT = new ArrayList<AST>();:}
                       ;

LISTA_INSTRUCCIONES ::= LISTA_INSTRUCCIONES:e INSTRUCCION:e1 {:RESULT = e; RESULT.add(e1);:}
                      | INSTRUCCION:e {:RESULT = new ArrayList<AST>(); RESULT.add(e);:}
                      ;

INSTRUCCION ::= WITH
              | ASIGNACION:e pComa {:RESULT = e;:}
              | TRANSFERENCIA
              //| SI
              | WHILE
              | REPEAT
              | FOR
              | WRITE
              | READ
              | SWITCH
              | free parenI EXPRESION parenD pComa
              | LLAMADA pComa
              ;

WITH ::= con identificador hacer BLOQUE_INSTRUCCIONES 
       | con identificador hacer INSTRUCCION
       ;

ASIGNACION ::= VARIABLE:e dosPuntos igual EXPRESION:e1 {: RESULT = new Asignacion(new Variable(e), e1, eleft, eright); :}
             ;

TRANSFERENCIA ::= detener pComa
                | continuar pComa
                | salir pComa
                ;

SI ::= si EXPRESION then INSIF
     | si EXPRESION then INSIF sino INSIF
     | si EXPRESION then INSIF LISTAIF
     | si EXPRESION then INSIF LISTAIF sino INSIF
     ;

LISTAIF ::= LISTAIF sino si EXPRESION then INSIF
          | sino si EXPRESION then INSIF
          ;

INSIF ::= INSTRUCCIONESIF
        | INSTRUCCIONESIF pComa
        | INSTRUCCION
        ;

INSTRUCCIONESIF ::= begin LISTA_INSTRUCCIONES end
                  | begin end
                  ;

SWITCH ::= caso EXPRESION of CASELIST end pComa
       | caso EXPRESION of CASELIST DEFECTO end pComa
       ;

CASELIST ::= CASELIST CASE
           | CASE
           ;

CASE ::= EXPRESION dosPuntos INSTRUCCION
       | EXPRESION dosPuntos BLOQUE_INSTRUCCIONES
       ;

DEFECTO ::= sino INSTRUCCION
          | sino BLOQUE_INSTRUCCIONES
          ;

WHILE ::= mientras EXPRESION hacer BLOQUE_INSTRUCCIONES pComa
        | mientras EXPRESION hacer INSTRUCCION
        ;

REPEAT ::= repeat LISTA_INSTRUCCIONES until EXPRESION pComa
         ;

FOR ::= para ASIGNACION to EXPRESION hacer BLOQUE_INSTRUCCIONES pComa
      | para ASIGNACION downto EXPRESION hacer BLOQUE_INSTRUCCIONES pComa
      | para ASIGNACION to EXPRESION hacer INSTRUCCION
      | para ASIGNACION downto EXPRESION hacer INSTRUCCION
      ;

WRITE ::= escribir parenI LISTA_EXPRESION parenD pComa
        | escribirln parenI LISTA_EXPRESION parenD pComa
        ; 

READ ::= leer parenI LISTA_IDENTIFICADORES parenD pComa
       ;

EXPRESION ::=  ARITMETICA:e                 {: RESULT = e; :}    
           |   LOGICA:e                     {: RESULT = e; :}
           |   RELACIONAL:e                 {: RESULT = e; :}
           |   PRIMITIVO:e                  {: RESULT = e; :}
           |   parenI EXPRESION:e parenD    {: RESULT = e; :}
           |   ACCESO:e                     {: RESULT = e; :}
           |   MEMORIA_VIRTUAL
           ;

ACCESO   ::= identificador:e {:RESULT = new Identificador(e, true, eleft,eright);:}
           | ACCESO corI LISTA_EXPRESION corD
           | ACCESO parenI LISTA_EXPRESION parenD
           | ACCESO punto identificador
           ;

LLAMADA ::= identificador parenI LISTA_EXPRESION parenD
          ;

ARITMETICA ::= menos  EXPRESION:e                 {: RESULT = new Operacion(e, Operador.MENOS_UNARIO, eleft, eright); :} %prec UMENOS 
             | EXPRESION:e mas EXPRESION:e1       {: RESULT = new Operacion(e, e1, Operador.SUMA, eleft, eright); :}
             | EXPRESION:e menos EXPRESION:e1     {: RESULT = new Operacion(e, e1, Operador.RESTA, eleft, eright); :}
             | EXPRESION:e por EXPRESION:e1       {: RESULT = new Operacion(e, e1, Operador.MULTIPLICACION, eleft, eright); :}
             | EXPRESION:e division EXPRESION:e1  {: RESULT = new Operacion(e, e1, Operador.DIVISION, eleft, eright); :}
             | EXPRESION:e potencia EXPRESION:e1  {: RESULT = new Operacion(e, e1, Operador.POTENCIA, eleft, eright); :}
             | EXPRESION:e modulo EXPRESION:e1    {: RESULT = new Operacion(e, e1, Operador.POTENCIA, eleft, eright); :}
             ;

RELACIONAL ::= EXPRESION:e mayorque EXPRESION:e1   {: RESULT = new Operacion(e, e1, Operador.MAYOR_QUE, eleft, eright); :}
             | EXPRESION:e mayorigual EXPRESION:e1 {: RESULT = new Operacion(e, e1, Operador.MAYOR_IGUAL, eleft, eright); :}
             | EXPRESION:e menorigual EXPRESION:e1 {: RESULT = new Operacion(e, e1, Operador.MENOR_IGUAL, eleft, eright); :}
             | EXPRESION:e menorque EXPRESION:e1   {: RESULT = new Operacion(e, e1, Operador.MENOR_QUE, eleft, eright); :}
             | EXPRESION:e igualacion EXPRESION:e1 {: RESULT = new Operacion(e, e1, Operador.IGUAL_IGUAL, eleft, eright); :}
             | EXPRESION:e diferente EXPRESION:e1  {: RESULT = new Operacion(e, e1, Operador.DIFERENTE_QUE, eleft, eright); :}
             ;

LOGICA ::= EXPRESION:e or EXPRESION:e1      {: RESULT = new Operacion(e, e1, Operador.OR, eleft, eright); :}
        |  EXPRESION:e and EXPRESION:e1     {: RESULT = new Operacion(e, e1, Operador.AND, eleft, eright); :}
        |  EXPRESION:e nand EXPRESION:e1    {: RESULT = new Operacion(e, e1, Operador.NAND, eleft, eright); :}
        |  EXPRESION:e nor EXPRESION:e1     {: RESULT = new Operacion(e, e1, Operador.NOR, eleft, eright); :}
        |  not EXPRESION:e                  {: RESULT = new Operacion(e, Operador.NOT, eleft, eright); :}
        ;

PRIMITIVO ::= cadena:e       {: RESULT = new Primitivo(e.toString()); :}
           | caracter:e      {: RESULT = new Primitivo(e); :}
           | verdadero:e     {: RESULT = new Primitivo(true); :}
           | falso:e         {: RESULT = new Primitivo(false); :}
           | numero:e        {: RESULT = new Primitivo(new Integer(e+"")); :}
           | decimal:e       {: RESULT = new Primitivo(new Double(e+"")); :}
           | nil:e           {: RESULT = new Primitivo(new Nil()); :}
           ;